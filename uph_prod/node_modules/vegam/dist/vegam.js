(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.vegam = {})));
}(this, (function (exports) { 'use strict';

var version = "0.0.4";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





















var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};





















var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/* vegam.js

vega minimal

'line', 'bar', 'barh', 'area', 'scatter', 'heatmap'

*/

function vegam() {
  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var self = {};
  self.data = data;
  self.options = options;
  self.layers = [];
  var core_spec = {
    '$schema': 'https://vega.github.io/schema/vega-lite/v2.json',
    autosize: { type: 'fit', contains: 'padding' },
    width: 300,
    height: 225,
    layer: self.layers };

  function _encode(c) {
    var _split = (c || '').split(':'),
        _split2 = slicedToArray(_split, 2),
        col = _split2[0],
        typ = _split2[1];

    if (typ == undefined) {
      return { field: c, type: self.VegaType(c) };
    }
    var typecodes = {
      Q: 'quantitative', O: 'ordinal', N: 'nominal',
      T: 'temporal' };
    return { field: col, type: typecodes[typ] };
  }

  function _stack(v) {
    // zero | normalize | centre | null
    return { 'stack': v === true ? 'zero' : v };
  }

  function _unflatten(data) {
    if (Object(data) !== data || Array.isArray(data)) return data;
    var result = {},
        cur,
        prop,
        idx,
        last,
        temp;
    for (var p in data) {
      cur = result, prop = '', last = 0;
      do {
        idx = p.indexOf('_', last);
        temp = p.substring(last, idx !== -1 ? idx : undefined);
        cur = cur[prop] || (cur[prop] = !isNaN(parseInt(temp)) ? [] : {});
        prop = temp;
        last = idx + 1;
      } while (idx >= 0);
      cur[prop] = data[p];
    }
    return result[''];
  }

  self.prepare = function () {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : self.data;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : self.options;

    if (Array.isArray(data) && !(data[0] instanceof Object)) {
      data = data.map(function (v, k) {
        return { 'data': v, '_index': k };
      });
    }
    self.spec = Object.assign({}, core_spec);
    self.spec.data = { 'values': data };
    self.data = data;
    self.options = options;
    return self;
  };

  self.getTypes = function (key) {
    // TODO: Use getTypes borrowed from g1
    var defaults$$1 = self.options.types || {};
    var v = self.data.length ? self.data[0][key] : '';
    return defaults$$1[key] || (typeof v === 'undefined' ? 'undefined' : _typeof(v));
  };

  self.VegaType = function (key) {
    // 'ordinal', 'nominal', 'quantitative', 'temporal'
    var typ = self.getTypes(key);
    if (typ === 'string') {
      return 'nominal';
    } else if (typ === 'number') {
      return 'quantitative';
    } else if (typ === 'date') {
      return 'temporal';
    } else {
      return 'nominal';
    }
  };

  self.addIndex = function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '_index';

    self.data.map(function (v, i) {
      return v[name] = i;
    });
    return self;
  };

  self.facet = function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        row = _ref.row,
        column = _ref.column;

    if (row === undefined && column === undefined) {
      return self;
    }
    self.spec.facet = _extends({}, row && { 'row': _encode(row) }, column && { 'column': _encode(column) });
    self.spec.spec = {};
    self.spec.spec.layer = self.layers;
    delete self.spec.layer;
    return self;
  };

  self.xy_layer = function () {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        x = _ref2.x,
        y = _ref2.y,
        x2 = _ref2.x2,
        y2 = _ref2.y2,
        color = _ref2.color,
        size = _ref2.size,
        order = _ref2.order,
        shape = _ref2.shape,
        text = _ref2.text,
        _ref2$mark = _ref2.mark,
        mark = _ref2$mark === undefined ? 'point' : _ref2$mark,
        column = _ref2.column,
        row = _ref2.row;

    var layer = {
      'mark': mark,
      'encoding': _extends({
        'x': _encode(x),
        'y': _encode(y)
      }, x2 && { 'x2': _encode(x2) }, y2 && { 'y2': _encode(y2) }, color && { 'color': _encode(color) }, size && { 'size': _encode(size) }, order && { 'order': _encode(order) }, shape && { 'shape': _encode(shape) }, text && { 'text': _encode(text) })
    };
    self.facet({ row: row, column: column });
    return layer;
  };

  self._xy = function () {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        x = _ref3.x,
        y = _ref3.y,
        x2 = _ref3.x2,
        y2 = _ref3.y2,
        color = _ref3.color,
        size = _ref3.size,
        order = _ref3.order,
        shape = _ref3.shape,
        text = _ref3.text,
        _ref3$mark = _ref3.mark,
        mark = _ref3$mark === undefined ? 'point' : _ref3$mark,
        row = _ref3.row,
        column = _ref3.column;

    var layer = self.xy_layer({
      x: x, y: y, x2: x2, y2: y2, color: color, size: size, order: order, shape: shape, text: text,
      mark: mark, row: row, column: column });
    self.layers.push(layer);
    return self;
  };

  self.line = function () {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        x = _ref4.x,
        y = _ref4.y,
        x2 = _ref4.x2,
        y2 = _ref4.y2,
        color = _ref4.color,
        order = _ref4.order,
        interpolate = _ref4.interpolate,
        _ref4$props = _ref4.props,
        props = _ref4$props === undefined ? {} : _ref4$props;

    var mark = Object.assign(_extends({
      'type': 'line'
    }, interpolate && { 'interpolate': interpolate }), props);
    self._xy({ x: x, y: y, x2: x2, y2: y2, color: color, order: order, mark: mark });
    return self;
  };

  self.bar = function () {
    var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        x = _ref5.x,
        y = _ref5.y,
        x2 = _ref5.x2,
        y2 = _ref5.y2,
        color = _ref5.color,
        _ref5$stack = _ref5.stack,
        stack = _ref5$stack === undefined ? null : _ref5$stack,
        order = _ref5.order,
        column = _ref5.column,
        row = _ref5.row,
        _ref5$props = _ref5.props,
        props = _ref5$props === undefined ? {} : _ref5$props;

    var mark = Object.assign({ 'type': 'bar' }, props);
    var layer = self.xy_layer({ x: x, y: y, x2: x2, y2: y2, color: color, order: order, mark: mark, column: column, row: row });
    Object.assign(layer.encoding.y, _stack(stack));
    self.layers.push(layer);
    return self;
  };

  self.barh = function () {
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        y = _ref6.y,
        x = _ref6.x,
        x2 = _ref6.x2,
        y2 = _ref6.y2,
        color = _ref6.color,
        _ref6$stack = _ref6.stack,
        stack = _ref6$stack === undefined ? null : _ref6$stack,
        order = _ref6.order,
        column = _ref6.column,
        row = _ref6.row,
        _ref6$props = _ref6.props,
        props = _ref6$props === undefined ? {} : _ref6$props;

    var mark = Object.assign({ 'type': 'bar' }, props);
    var layer = self.xy_layer({ x: x, y: y, x2: x2, y2: y2, color: color, order: order, mark: mark, column: column, row: row });
    Object.assign(layer.encoding.x, _stack(stack));
    self.layers.push(layer);
    return self;
  };

  self.area = function () {
    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        x = _ref7.x,
        y = _ref7.y,
        x2 = _ref7.x2,
        y2 = _ref7.y2,
        color = _ref7.color,
        _ref7$stack = _ref7.stack,
        stack = _ref7$stack === undefined ? null : _ref7$stack,
        interpolate = _ref7.interpolate,
        _ref7$props = _ref7.props,
        props = _ref7$props === undefined ? {} : _ref7$props;

    self.bar({ x: x, y: y, x2: x2, y2: y2, color: color, stack: stack });
    var mark = Object.assign(_extends({
      'type': 'area'
    }, interpolate && { 'interpolate': interpolate }), props);
    self.layers[self.layers.length - 1].mark = mark;
    return self;
  };

  self.xy = function () {
    var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        x = _ref8.x,
        y = _ref8.y,
        x2 = _ref8.x2,
        y2 = _ref8.y2,
        color = _ref8.color,
        size = _ref8.size,
        shape = _ref8.shape,
        _ref8$mark = _ref8.mark,
        mark = _ref8$mark === undefined ? 'point' : _ref8$mark,
        column = _ref8.column,
        row = _ref8.row;

    self._xy({ x: x, y: y, x2: x2, y2: y2, color: color, size: size, shape: shape, mark: mark, column: column, row: row });
    return self;
  };

  self.scatter = function () {
    var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        x = _ref9.x,
        y = _ref9.y,
        color = _ref9.color,
        size = _ref9.size,
        shape = _ref9.shape,
        column = _ref9.column,
        row = _ref9.row,
        _ref9$props = _ref9.props,
        props = _ref9$props === undefined ? {} : _ref9$props;

    var mark = Object.assign({ 'type': shape ? 'point' : 'circle' }, props);
    self._xy({ x: x, y: y, color: color, size: size, shape: shape, mark: mark, column: column, row: row });
    return self;
  };

  self.strip = function () {
    var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        x = _ref10.x,
        y = _ref10.y,
        color = _ref10.color,
        size = _ref10.size,
        shape = _ref10.shape,
        column = _ref10.column,
        row = _ref10.row,
        _ref10$props = _ref10.props,
        props = _ref10$props === undefined ? {} : _ref10$props;

    var mark = Object.assign({ 'type': 'tick' }, props);
    self._xy({ x: x, y: y, color: color, size: size, shape: shape, mark: mark, column: column, row: row });
    return self;
  };

  self.labels = function () {
    var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        x = _ref11.x,
        y = _ref11.y,
        _ref11$text = _ref11.text,
        text = _ref11$text === undefined ? y : _ref11$text,
        color = _ref11.color,
        size = _ref11.size,
        shape = _ref11.shape,
        _ref11$props = _ref11.props,
        props = _ref11$props === undefined ? {} : _ref11$props;

    var mark = Object.assign({ 'type': 'text' }, props);
    self._xy({ x: x, y: y, color: color, size: size, shape: shape, mark: mark, text: text });
    return self;
  };

  self.heatmap = function () {
    var _ref12 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        x = _ref12.x,
        y = _ref12.y,
        _ref12$color = _ref12.color,
        color = _ref12$color === undefined ? null : _ref12$color,
        _ref12$size = _ref12.size,
        size = _ref12$size === undefined ? null : _ref12$size,
        _ref12$agg = _ref12.agg,
        agg = _ref12$agg === undefined ? 'sum' : _ref12$agg,
        _ref12$mark = _ref12.mark,
        mark = _ref12$mark === undefined ? 'rect' : _ref12$mark,
        maxbins = _ref12.maxbins;

    function _agg_encode(channel, agg) {
      return !channel ? {
        'aggregate': 'count', 'type': 'quantitative'
      } : {
        'field': channel, 'aggregate': agg, 'type': 'quantitative' };
    }

    var encoding,
        ex = _encode(x),
        ey = _encode(y);
    if (maxbins) {
      var bins = { 'bin': { 'maxbins': maxbins } };
      encoding = {
        'x': ex.type == 'quantitative' ? Object.assign({}, ex, bins) : ex,
        'y': ey.type == 'quantitative' ? Object.assign({}, ey, bins) : ey
      };
    } else {
      encoding = {
        'x': { 'field': x, 'type': ex.type == 'quantitative' ? 'ordinal' : 'nominal' },
        'y': { 'field': y, 'type': ex.type == 'quantitative' ? 'ordinal' : 'nominal' }
      };
    }
    var is_size = mark != 'rect' || size !== null;
    var is_color = mark == 'rect' || color !== null;
    Object.assign(encoding, _extends({}, is_size && { size: _agg_encode(size, agg) }, is_color && { color: _agg_encode(color, agg) }));
    var layer = {
      'mark': mark,
      'encoding': encoding
    };
    self.layers.push(layer);
    return self;
  };

  self.chart = function () {
    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var type = o.hasOwnProperty('chart') ? o.chart : 'xy';
    self[type](o);
    return self;
  };

  self.addLayer = function () {};

  self.style = function () {
    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    // updates all layers or the root
    // o contains special n key for layers to affect on
    o = Object.assign({}, o);
    var n = 'n' in o ? o.n : false;
    delete o.n;
    var expanded_o = _unflatten(o);
    // apply on root
    if (n === 0) {
      for (var key in expanded_o) {
        self.spec[key] = expanded_o[key];
      }
      return self;
    }
    var layers = n > 0 ? self.layers.slice(0, n) : self.layers.slice(n);
    layers.forEach(function (L) {
      for (var key in expanded_o) {
        if (L.encoding.hasOwnProperty(key)) {
          Object.assign(L.encoding[key], expanded_o[key]);
        }
      }
    });
    return self;
  };

  self.resolve = function () {
    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    self.spec.resolve = _unflatten(o);
    return self;
  };

  self.fromjson = function () {
    var ops = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    // Instead of chaining, use array of operations [{},{},{}] to be applied
    ops.forEach(function (op) {
      op = Object.assign({}, op);
      if (op.apply === 'prepare' || typeof op.apply === 'undefined') {
        self.prepare(op.data, op.options);
      } else {
        var method = op.apply;
        delete op.apply;
        self[method](op);
      }
    });
    return self;
  };

  // TODO
  self.draw = function () {};

  self.update = function (config) {
    // shallow copy
    self.spec = Object.assign({}, self.spec, config);
    return self;
  };

  self.prepare();
  return self;
}

exports.version = version;
exports.vegam = vegam;

Object.defineProperty(exports, '__esModule', { value: true });

})));
