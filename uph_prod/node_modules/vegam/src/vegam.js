/* vegam.js

vega minimal

'line', 'bar', 'barh', 'area', 'scatter', 'heatmap'

*/

export function vegam(data=[], options={}) {
  var self = {}
  self.data = data
  self.options = options
  self.layers = []
  var core_spec = {
    '$schema': 'https://vega.github.io/schema/vega-lite/v2.json',
    autosize: {type: 'fit', contains: 'padding'},
    width: 300,
    height: 225,
    layer: self.layers}

  function _encode(c) {
    var [col, typ] = (c || '').split(':')
    if (typ == undefined) {
      return {field: c, type: self.VegaType(c)}
    }
    var typecodes = {
      Q: 'quantitative', O: 'ordinal', N: 'nominal',
      T: 'temporal'}
    return {field: col, type: typecodes[typ]}
  }

  function _stack(v) {
    // zero | normalize | centre | null
    return {'stack': (v === true)?'zero':v}
  }

  function _unflatten(data) {
    if (Object(data) !== data || Array.isArray(data))
      return data
    var result = {}, cur, prop, idx, last, temp
    for(var p in data) {
      cur = result, prop = '', last = 0
      do {
        idx = p.indexOf('_', last)
        temp = p.substring(last, (idx !== -1)?idx:undefined)
        cur = cur[prop] || (cur[prop]=(!isNaN(parseInt(temp))?[]:{}))
        prop = temp
        last = idx + 1
      } while(idx >= 0)
      cur[prop] = data[p]
    }
    return result['']
  }

  self.prepare = function(data=self.data, options=self.options) {
    if (Array.isArray(data) && !(data[0] instanceof Object)) {
      data = data.map((v, k) => ({'data':v, '_index': k}))
    }
    self.spec = Object.assign({}, core_spec)
    self.spec.data = {'values': data}
    self.data = data
    self.options = options
    return self
  }

  self.getTypes = function(key) {
    // TODO: Use getTypes borrowed from g1
    var defaults = self.options.types || {}
    var v = (self.data.length)?self.data[0][key]:''
    return (defaults[key] || typeof v)
  }

  self.VegaType = function(key) {
    // 'ordinal', 'nominal', 'quantitative', 'temporal'
    var typ = self.getTypes(key)
    if (typ === 'string') {
      return 'nominal'
    } else if (typ === 'number') {
      return 'quantitative'
    } else if (typ === 'date') {
      return 'temporal'
    } else {
      return 'nominal'
    }
  }

  self.addIndex = function(name='_index') {
    self.data.map((v, i) => v[name] = i)
    return self
  }

  self.facet = function({row, column}={}) {
    if (row === undefined && column === undefined) {
      return self
    }
    self.spec.facet = {
      ...row && {'row': _encode(row)},
      ...column && {'column': _encode(column)}
    }
    self.spec.spec = {}
    self.spec.spec.layer = self.layers
    delete self.spec.layer
    return self
  }

  self.xy_layer = function({
    x, y, x2, y2, color, size, order, shape, text, mark='point',
    column, row}={}) {
    var layer = {
      'mark': mark,
      'encoding': {
        'x': _encode(x),
        'y': _encode(y),
        ...x2 && {'x2': _encode(x2)},
        ...y2 && {'y2': _encode(y2)},
        ...color && {'color': _encode(color)},
        ...size && {'size': _encode(size)},
        ...order && {'order': _encode(order)},
        ...shape && {'shape': _encode(shape)},
        ...text && {'text': _encode(text)}
      }
    }
    self.facet({row, column})
    return layer
  }

  self._xy = function({
    x, y, x2, y2, color, size, order, shape, text,
    mark='point', row, column}={}) {
    var layer = self.xy_layer({
      x, y, x2, y2, color, size, order, shape, text,
      mark, row, column})
    self.layers.push(layer)
    return self
  }

  self.line = function({x, y, x2, y2, color, order, interpolate, props={}}={}) {
    var mark = Object.assign({
      'type': 'line',
      ...interpolate && {'interpolate': interpolate}
    }, props)
    self._xy({x, y, x2, y2, color, order, mark})
    return self
  }

  self.bar = function({x, y, x2, y2, color, stack=null, order, column, row, props={}}={}) {
    var mark = Object.assign({'type': 'bar'}, props)
    var layer = self.xy_layer({x, y, x2, y2, color, order, mark, column, row})
    Object.assign(layer.encoding.y, _stack(stack))
    self.layers.push(layer)
    return self
  }

  self.barh = function({y, x, x2, y2, color, stack=null, order, column, row, props={}}={}) {
    var mark = Object.assign({'type': 'bar'}, props)
    var layer = self.xy_layer({x, y, x2, y2, color, order, mark, column, row})
    Object.assign(layer.encoding.x, _stack(stack))
    self.layers.push(layer)
    return self
  }

  self.area = function({x, y, x2, y2, color, stack=null, interpolate, props={}}={}) {
    self.bar({x, y, x2, y2, color, stack})
    var mark = Object.assign({
      'type': 'area',
      ...interpolate && {'interpolate': interpolate}},
    props)
    self.layers[self.layers.length-1].mark = mark
    return self
  }

  self.xy = function({x, y, x2, y2, color, size, shape, mark='point', column, row}={}) {
    self._xy({x, y, x2, y2, color, size, shape, mark, column, row})
    return self
  }

  self.scatter = function({x, y, color, size, shape, column, row, props={}}={}) {
    var mark = Object.assign({'type': (shape)?'point':'circle'}, props)
    self._xy({x, y, color, size, shape, mark, column, row})
    return self
  }

  self.strip = function({x, y, color, size, shape, column, row, props={}}={}) {
    var mark = Object.assign({'type': 'tick'}, props)
    self._xy({x, y, color, size, shape, mark, column, row})
    return self
  }

  self.labels = function({x, y, text=y, color, size, shape, props={}}={}) {
    var mark = Object.assign({'type': 'text'}, props)
    self._xy({x, y, color, size, shape, mark, text})
    return self
  }

  self.heatmap = function({x, y, color=null, size=null, agg='sum', mark='rect', maxbins}={}) {
    function _agg_encode(channel, agg) {
      return (!channel)?{
        'aggregate': 'count', 'type': 'quantitative'
      }:{
        'field': channel, 'aggregate': agg, 'type': 'quantitative'}
    }

    var encoding,
        ex = _encode(x),
        ey = _encode(y)
    if (maxbins) {
      var bins = {'bin': {'maxbins': maxbins}}
      encoding = {
        'x': (ex.type == 'quantitative')?Object.assign({}, ex, bins):ex,
        'y': (ey.type == 'quantitative')?Object.assign({}, ey, bins):ey
      }
    } else {
      encoding = {
        'x': {'field': x, 'type': (ex.type == 'quantitative')?'ordinal':'nominal'},
        'y': {'field': y, 'type': (ex.type == 'quantitative')?'ordinal':'nominal'}
      }
    }
    var is_size = ((mark != 'rect') || (size !== null))
    var is_color = ((mark == 'rect') || (color !== null))
    Object.assign(encoding, {
      ...is_size && {size: _agg_encode(size, agg)},
      ...is_color && {color: _agg_encode(color, agg)}
    })
    var layer = {
      'mark': mark,
      'encoding': encoding
    }
    self.layers.push(layer)
    return self
  }

  self.chart = function(o={}) {
    var type = o.hasOwnProperty('chart')?o.chart:'xy'
    self[type](o)
    return self
  }

  self.addLayer = function() {
  }

  self.style = function(o={}) {
    // updates all layers or the root
    // o contains special n key for layers to affect on
    o = Object.assign({}, o)
    var n = ('n' in o)?o.n:false
    delete o.n
    var expanded_o = _unflatten(o)
    // apply on root
    if (n === 0) {
      for (var key in expanded_o) {
        self.spec[key] = expanded_o[key]
      }
      return self
    }
    var layers = (n>0)?self.layers.slice(0,n):self.layers.slice(n)
    layers.forEach(function(L) {
      for (var key in expanded_o) {
        if (L.encoding.hasOwnProperty(key)) {
          Object.assign(L.encoding[key], expanded_o[key])
        }
      }
    })
    return self
  }

  self.resolve = function(o={}) {
    self.spec.resolve = _unflatten(o)
    return self
  }

  self.fromjson = function(ops=[]) {
    // Instead of chaining, use array of operations [{},{},{}] to be applied
    ops.forEach(function(op) {
      op = Object.assign({}, op)
      if (op.apply === 'prepare' || typeof op.apply === 'undefined') {
        self.prepare(op.data, op.options)
      } else {
        var method = op.apply
        delete op.apply
        self[method](op)
      }
    })
    return self
  }

  // TODO
  self.draw = function() {
  }

  self.update = function(config) {
    // shallow copy
    self.spec = Object.assign({}, self.spec, config)
    return self
  }

  self.prepare()
  return self
}
